# 1. 데이터 타입

## 1-1. 데이터 타입의 종류

- 기본형 : number, string, boolean, null, undefined, Symbol
- 참조형 : Object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등

\*\* Symbol?

- https://another-light.tistory.com/105
- typescript의 `"some string" as const` 와 비슷한 것 같다.
- Object에서 key를 숨기거나 javascript에서 enum을 만들 때 활용할 수 있다.
- 아마 javascript class의 private field(#filedName)을 구현할 때 사용했을 것 같다.
  - 찾아보니 symbol로 구현했다고 나와있진 않고 비슷한 원리로 구현했을 것 같다. 나중에 javascript에 대해 더 깊게 알아볼 때 찾아보자

#### 기본형 vs 참조형

- 기본형은 할당이나 연산시 복제되고 참조형은 참조된다
  - 참조형 - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제

## 1-2. 데이터 타입에 관한 배경지식

### 1-2-1. 메모리와 데이터

- 비트(bit) : 0 또는 1만 표현할 수 있는 하나의 메모리 조각
  - 각 비트는 고유한 식별자를 통해 위치를 확인할 수 있음
- 비트 단위로 위치를 확인하는 것은 매우 비효율적이기 때문에 묶어서 하나의 단위로 표현
  - 낭비되는 비트가 생기기도 함
- 바이트(byte) : 8비트로 구성
  - 2의 8승(256)개의 값을 표현할 수 있음
  - 2바이트 : 16비트 => 65536(2의 16승)개의 값을 표현할 수 있음
- c/c++

  - short : 2바이트 => -32768 ~ +32767
  - int : 4바이트
  - float
  - double

- javascript

  - 메모리 용량이 과거보다 커졌으므로 자바스크립트는 넉넉하게 할당함
  - 숫자를 정수형인지 부동소수형인지 구분하지 않고 8바이트(= 64비트)를 확보

- 바이트 역시 시작하는 비트의 식발자로 위치를 파악
- 모든 데이터는 바이트 단위의 식별자, `메모리 주솟값`을 통해 서로 구분하고 연결 할 수 있음

### 1-2-2. 식별자와 변수

- 변수 : 변할 수 있는 무언가(데이터) - 숫자, 문자열, 객체, 배열 등
- 식별자 : 변수명

## 1-3. 변수 선언과 데이터 할당

### 1-3-1. 변수 선언

- 여기서 다룰 내용은 방법이 아닌 동작원리

```js
// 예제 1-1. 변수 선언
var a;
```

- 위 예제를 말로 풀어쓰면

  - 변할 수 있는 데이터를 만든다.
  - 이 데이터의 식별자는 a로 한다.

- (예제 1-1에 대한)변수 선언에 대한 메모리 영역의 변화
  - 비어있는 공간 하나를 확보
    - e.g., 1003번
  - 이 공간의 이름(식별자)을 `a`라고 지정
  - 이후 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환

### 1-3-2. 데이터 할당

```js
// 예제 1-2. 변수 선언과 할당
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

1. 데이터 'abc'를 저장하기 위한 별도의 메모리 공간을 확보해서 문자열 'abc'를 저장

- 데이터 영역(주소 : 5004)

2. 1.에서 저장한 데이터가 있는 주소를 변수 a에 저장

- 변수 영역(주소 : 1003 -> @5004)

- (예제 1-2에 대한) 데이터 할당에 대한 메모리 영역의 변화
  - 변수 영역에서 빈 공강(@1003)을 확보한다.
  - 확보한 공간의 식별자를 a로 지정한다.
  - 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다.
  - 변수 영역에서 a라는 식별자를 검색한다(@1003)
  - 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

* 변수 영역에 값을 직접 대입 하지 않고 번거롭게 한단계를 더 거치는 이유

  - 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위해서
  - js는 숫자형에 8바이트를 확보하지만 문자열엔 정해진 바이트가 없음(영어 1바이트, 한글 2바이트)
  - 문자열은 필요 메모리가 가변적임
  - 수정할 경우 새로 만들어서 새로만든 주소를 식별자 주소에 덮어쓰기 함
    - 기존 데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터의 수거 대상이 됨

* 변수에 숫자를 할당하는 경우 기존에 있는 숫자라면 새로 만들지 않고 기존에 있는 숫자의 주소값을 할당함
  - 할당된 숫자를 수정하는 경우 새로 만들고 새로만든 주소를 기존 숫자주소에 덮어쓰기하고
  - 만약 기존 숫자데이터의 경우 자신의 주소를 저장하는 변수가 하나도 없으면 가비지 컬렉터에 의해 수거 됨

## 1-4. 기본형 데이터와 참조형 데이터

### 1-4-1. 불변값

- 변수 vs 상수 => 변경 가능성 차이

  - 불변값 != 상수

- 변수와 상수를 구분 짓는 변경 가능성의 대상 : `변수 영역` 메모리
- 불변성 여부를 구분할 때의 변경 가능성의 대상 : `데이터 영역` 메모리

- `기본형 데이터`인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 `불변값`

### 1-4-2. 가변값

- `참조형 데이터`는 `가변 값`

```js
// 예제 1-4 참조형 데이터의 할당
var obj1 = {
  // 주소 1002 => 이름: obj1, 값: @5001 // 주소 5001 => @7103 ~ ?(미정)
  a: 1, // 주소 7103 => 이름: a, 값: @5003 // 주소 5003 => 1
  b: "bbb", // 주소 7104 => 이름: b, 값: @5004 // 주소 5004 => 'bbb'
};
```

```js
// 예제 1-6 중첩된 참조형 데이터(객체)의 프로퍼티 할당
var obj = {
  // 주소 1002 => 이름:obj, 값: @5001 // 주소 5001 => @7103 ~ ?
  x: 3, // 주소 7103 => 이름: x, 값: @5002 // 주소 5002 => 3
  arr: [3, 4, 5], // 주소 7104 => 이름: arr, 값: @5003 // 주소 5003 => @8104 ~ ?
  // 주소 8104 => 이름: 0(인덱스 0), 값: @5002(3을 검색해보니 5002에 있기 때문)
  // 주소 8105 => 이름: 1(인덱스 1), 값: @5004(4를 검색했는데 없어서 새로 만들고 할당) => 주소 5004 => 4
  // 주소 8106 => 이름: 2(인덱스 2), 값: @5005(5를 검색했는데 없어서 새로 만들고 할당) => 주소 5005 => 5
};
```

- obj.arr[1] 검색 과정
  - @1002 -> @5001 -> (@7103 ~ ?) -> @7104 -> @5003 -> (@8104 ~ ?) -> @8105 -> @5004 -> 4반환

### 1-4-3. 변수 복사 비교

- 변수 복사 시 기본형 데이터와 참조형 데이터 차이를 확인해보자

```js
// 예제 1-7. 변수 복사
var a = 10; // 주소 1001 => 이름: a, 값: @5001 // 주소 5001 => 10
var b = a; // 주소 1002 => 이름: b, 값: @5001 // a의 값에 해당하는 주소를 복사

var obj1 = { c: 10, d: "bbb" }; // 주소 1003 => 이름: obj1, 값: @5002 // 주소 5002 => (@7103 ~ ?)
var obj2 = obj1; // 주소 1004 => 이름: obj2, 값: @5002 // 똑같이 복사
```

- 복사 과정은 동일 하지만 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생합니다.
- b에 새로운 숫자를 할당하면 그 숫자에 대한 주소로 변경이 되지만
- obj2의 c를 변경해도 obj2에 할당된 주소는 변경되지 않고 c에 새로운 숫자에 대한 주소가 할당되기 때문에
- obj1과 obj2 모두 영향을 받음 => 기본형과 참조형 데이터의 가장 큰 차이점

## 1-5. 불변 객체

### 1-5-1. 불변 객체를 만드는 간단한 방법

- 불변 객체는 최근 React, Vue.js, Angular 등의 라이브러리나 프레임워크에서뿐만 아니라
  함수형 프로그래밍, 디자인 패턴 등에서도 매우 중요한 기초가 되는 개념
- 참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립
- 기본형 처럼 참조형에도 객체 자체를 다시 할당하고자 한다면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않음

```js
// 예제 1-11. 객체의 가변성에 따른 문제점의 해결 방법
var user = {
  name: "Tony",
  gender: "male",
};

var changeName = function (user, newName) {
  // bad case
  // var newUser = user;
  // newUser.name = newName;
  // return newUser;

  // good case
  return {
    name: newName,
    gender: user.gender,
  };
};
```

```js
// 예제 1-12. 기존 정보를 복사해서 새로운 객체를 반환하는 함수(얕은 복사)
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

### 1-5-2. 얕은 복사와 깊은 복사

- 얕은 복사는 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법

```js
// 예제 1-14. 중첩된 객체에 대한 얕은 복사
var user = {
  name: "Tony",
  urls: {
    portfolio: "https://github.com/TaehwanGo",
    blog: "https://velog.io/@gth1123",
  },
};
```

- 예제 1-12의 복사함수로는 중첩된 객체안의 값이 변경되는 것 까지 방지할 순 없음

  - user.urls.portfolio 가 변경되면 원본에도 영향을 줌

- 참조형 데이터가 있을 때 마다 재귀적으로 수행해야만 비로소 깊은 복사가 됨

```js
// 예제 1-16. 객체의 깊은 복사를 수행하는 범용 함수
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
```

- target !== null : null에 대해서도 'object'를 반환하기 때문(자바스크립트 자체의 버그)
- Object.hasOwnProperty 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게 할 수도 있음
- ES5의 getter/setter를 복사하는 방법
  - ES6의 Object.getOwnPropertyDescriptor
  - ES2017의 Object.getOwnPropertyDescriptors

* 깊은 복사를 처리할 수 있는 다른 방법

- JSON문자열로 전환했다가 다시 JSON 객체로 바꾸는 것
- **다만 메서드(함수)나 숨겨진 프로퍼티인 **proto**나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼니들은 모두 무시**
- httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법
